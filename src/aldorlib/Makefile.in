# (Patch) Subject: Re: aldor/axiom interoperability
# http://article.gmane.org/gmane.comp.mathematics.axiom.devel/19315/match=broadbery

subdir=src/aldorlib/
srcdir=@srcdir@
VPATH=@srcdir@
MAKEFLAGS += -Wwarn-undefined-variables
ALDOR=@ALDOR@

scripts := build-dep show
testscripts := test-build-dep

lang := lang init_Generator Void Tuple Basic
environment := System

attributes := unitsKnown noZeroDivisors CommutativeStar			\
	      canonicalUnitNormal finiteAggregate shallowlyMutable	\
	      CharacteristicNonZero CharacteristicZero Approximate	\
	      additiveValuation multiplicativeValuation			\
	      canonicalsClosed

integers := x/I init_Integer init_NonNegativeInteger		\
	    init_PositiveInteger init_SingleInteger		\
	    PositiveInteger_Base PositiveInteger Integer	\
	    NonNegativeInteger Integer_SetCategory		\
	    Integer_OrderedRing Integer_IntegralDomain		\
	    Integer_EuclideanDomain IntegerMod SingleInteger	\
	    NonNegativeInteger_OrderedAbelianMonoidSup		\
	    NonNegativeInteger_SemiRing

integers2 := IntegerNumberSystem0 IntegerNumberSystem	\
	     Integer_RealConstant IntegerFactorizationPackage \
	     IntegerPrimesPackage IntegerRoots

basics := x/G x/C x/X CoercibleTo FullyRetractableTo RetractableTo	\
          ConvertibleTo SetCategory init_String BasicType		\
          OrderedFinite init_Boolean String init_InputForm		\
          RepeatedDoubling RepeatedSquaring init_Symbol Symbol		\
          Symbol_SetCategory init_Character Character_Base Logic	\
          Character init_Pointer String_SetCategory			\
          String_OneDimensionalArrayAggregate Reference Boolean		\
          Boolean_SetCategory

inputs := init_Pattern Any None NoneFunctions1 AnyFunctions1		\
	   InputForm PatternMatchable init_PatternMatchResult		\
	   Patternable PatternFunctions1 FullyPatternMatchable		\
	   PatternMatchQuotientFieldCategory PatternMatchPushDown
#Pattern

outputs := init_OutputForm OutputForm NumberFormats	\
	   OutputFormLisp

maths := x/Self x/Self2 Finite Finite2 AbelianGroup			\
         CancellationAbelianMonoid AbelianMonoid AbelianSemiGroup	\
         Group Ring Rng SemiRng SemiGroup SemiRing Monoid LeftModule	\
         Partial RightModule BiModule Module CommutativeRing	\
         EntireRing Algebra DifferentialRing DifferentialExtension	\
         PartialDifferentialRing Field0 StepThrough			\
         FullyLinearlyExplicitRingOver LinearlyExplicitRingOver		\
         UniqueFactorizationDomain Field

domains := PrincipalIdealDomain0 PrincipalIdealDomain GcdDomain0	\
           GcdDomain IntegralDomain EuclideanDomain0 EuclideanDomain	\
           IdealElt

floats := init_DoubleFloat init_Float DoubleFloat_SetCategory		\
	  DoubleFloat RealConstant Float_SetCategory Float_Field0	\
	  DoubleFloat_Field0

_sexprs := init_SExpression SExpressionCategory	\
	   SExpression_SExpressionCategory

sexprs  := $(patsubst %, sexpr/%, $(_sexprs))

fractions := Localize init_Fraction DivisionRing LocalAlgebra		\
	     Fraction_CommutativeRing Fraction_DivisionRing		\
	     QuotientFieldCategory0 QuotientFieldCategory1		\
	     QuotientFieldCategory Fraction_QuotientFieldCategory0	\
	     CommonDenominator Fraction_QuotientFieldCategory1 

factoreds := x/PFE init_Factored Factored_Base Factored	\
             PolynomialFactorizationExplicit		\
             PolynomialFactorizationExplicit0		\
             LinearPolynomialEquationByFractions

randoms := RandomNumberGenerator RandomNumberSource

poly := x/A x/AC PolynomialRing FiniteAbelianMonoidRing			\
	AbelianMonoidRing SingletonAsOrderedSet FreeModule		\
	AbelianProductCategory IndexedDirectProductCategory		\
	IndexedDirectProductObject FreeModuleCategory			\
	UnivariatePolynomialCategory0					\
	SparseUnivariatePolynomial_FiniteAbelianMonoidRing		\
	PolynomialCategory0 init_SparseUnivariatePolynomial		\
	SparseUnivariatePolynomial_UnivariatePolynomialCategory0	\
	PseudoRemainderSequence UnivariatePolynomialCategory		\
	PolynomialCategory SparseUnivariatePolynomial_R			\
	SparseUnivariatePolynomial_UnivariatePolynomialCategory		\
	UnivariatePolynomialCategoryFunctions2

multpoly := #Polynomial UserDefinedPartialOrdering	\
	    #SparseMultivariatePolynomial IndexedExponents

orders := PartialOrder OrderedSet Comparable OrderedAbelianGroup	\
	  OrderedAbelianMonoid OrderedAbelianSemiGroup			\
	  OrderedCancellationAbelianMonoid OrderedIntegralDomain	\
	  OrderedRing OrderedAbelianMonoidSup

datatypes := x/R x/FSA init_List Aggregate HomogeneousAggregate List	\
	     Set Fold SetAggregate FiniteSetAggregate			\
	     IndexedFlexibleArray FlexibleArray BagAggregate		\
	     Dictionary DictionaryOperations RecursiveAggregate		\
	     UnaryRecursiveAggregate LinearAggregate StreamAggregate	\
	     Collection IndexedAggregate EltableAggregate Eltable	\
	     List_StreamAggregate FiniteLinearAggregate			\
	     FiniteLinearAggregateSort IndexedOneDimensionalArray	\
	     ExtensibleLinearAggregate List_ExtensibleLinearAggregate	\
	     BitAggregate IndexedBits ListAggregate			\
	     List_ListAggregate

segments := x/S x/S1 x/S2 x/S3 x/H x/LU init_UniversalSegment		\
	    init_Segment SegmentCategory SegmentExpansionCategory	\
	    UniversalSegment Segment_SegmentCategory Segment		\
	    OrderedSemiRingSegment

equations := Evalable InnerEvalable Equation_SetCategory	\
	     init_Equation FullyEvalableOver

trig := RadicalCategory CombinatorialFunctionCategory

arrays := init_PrimitiveArray PrimitiveArray_Base PrimitiveArray	\
	  InnerIndexedTwoDimensionalArray				\
	  OneDimensionalArrayAggregate TwoDimensionalArrayCategory \

linalg := init_Vector init_Matrix Matrix_TwoDimensionalArrayCategory	\
	   Vector_FiniteLinearAggregate VectorCategory			\
	   IndexedVector_FiniteLinearAggregate IndexedVector Vector	\
	   MatrixCategory Matrix_MatrixCategory 

axioms := axioms/Stream axioms/RandomGenerator axioms/AxiomEnv	\
	  axioms/Axiom axioms/AxiomConstructorPackage

testsupport := tests/Assert tests/Assertions tests/TestCategory

tests := tests/TestOutputForm tests/TestSExpression tests/TestInt	\
	 tests/TestFold tests/TestString tests/TestTuple		\
	 tests/TestList tests/TestPrimitiveArray			\
	 tests/TestList_StreamAggregate tests/TestVector		\
	 tests/TestIndexedDirectProduct tests/TestUniversalSegment	\
	 tests/TestOrderedSemiRingSegment				\
	 tests/TestPseudoRemainderSequence tests/TestPolynomialRing	\
	 tests/TestSUP0 tests/TestP0

runtime_native := runtime/native/Local runtime/native/rtexns	\
		runtime/native/LString runtime/native/SExpression

other := GaussianInteger

runtime_lisp := runtime/lisp/Local runtime/lisp/rtexns runtime/lisp/LString	\
		runtime/lisp/SExpression

library := $(lang) $(other) $(sexprs) $(outputs) $(randoms) $(axioms)	\
	   $(arrays) $(tests) $(testsupport) $(datatypes) $(linalg)	\
	   $(trig) $(factoreds) $(poly) $(integers) $(floats)		\
	   $(fractions) $(maths) $(attributes) $(environment)		\
	   $(basics) $(segments) $(orders) $(domains) $(equations)	\
	   $(multpoly) $(integers2) $(inputs)

#opts_x/I := -WD+inline -WD+inlCall -Q9 -WD+inlCallInfo

reqfiles := $(patsubst %, common/%.req, $(library) $(runtime_native) $(runtime_lisp))

native_library := $(patsubst %, native/%, $(library) $(runtime_native))
lisp_library := $(patsubst %, lisp/%, $(library) $(runtime_lisp))

native_tests := $(patsubst %, native/%, $(tests))
lisp_tests := $(patsubst %, lisp/%, $(tests))

all: run-all-tests check-tests compile-aofiles

lisp: compile-lisp lisp/load.input lisp/stuff.lisp
compile-lisp:
	@echo LISP $(words $(shell cat lisp/load.input.dep)) files
	@make $(patsubst %,lisp/%.lsp, $(shell cat lisp/load.input.dep))

list-srcfiles:
	@echo $(patsubst %, %.as, $(library))

compile-aofiles: $(patsubst %,%.ao,$(native_library))
compile-fmfiles: $(patsubst %,%.fm,$(native_library))
compile-ofiles: $(patsubst %,%.o, $(native_library))
compile-tests: $(patsubst %, %.exe, $(native_tests))

compile-axiom: $(patsubst %, %.lsp, $(lisp_library))

gloop-tests: $(patsubst %,gloop-%, $(filter %/Test%, $(native_tests)))
check-tests: $(patsubst %,check-%, $(tests))

lisp-inputs: $(patsubst %, lisp/%.ao, $(inputs))

-include $(patsubst %,%.mk, $(native_library))
-include $(patsubst %,%.mk, $(lisp_library))

$(patsubst %,%.dep,$(library)): %.dep: $(srcdir)/%.as

dependencies = $(shell cat $(srcdir)/$*.as | sed -n -e 's/ARCH/$(arch)/g;/^--DEPS:/s/^--DEPS://p')

$(patsubst %,%.mk, $(native_library)): arch = native
$(patsubst %,%.mk, $(native_library)): stem = native/$*
$(patsubst %,%.mk, $(native_library)): native/%.mk: $(srcdir)/%.as
	@echo MK $@
	@if [ ! -d $(dir $@) ]; then mkdir -p $(dir $@); fi
	@echo > $@.tmp
	@for i in $(patsubst %, %, $(dependencies));\
	 do \
		echo "$(stem).ao: native/$$i.ao" >> $@.tmp;       \
		echo "$(stem).dep: native/$$i.dep" >> $@.tmp;     \
		echo "gloop-$*: native/$$i.ao" >> $@.tmp;    \
		echo "gloop-$*: native/$$i.dep" >> $@.tmp;    \
	 done;  \
	 mv $@.tmp $@

$(patsubst %,%.mk, $(lisp_library)): arch = lisp
$(patsubst %,%.mk, $(lisp_library)): stem = lisp/$*
$(patsubst %,%.mk, $(lisp_library)): lisp/%.mk: $(srcdir)/%.as
	@echo MK $@
	@if [ ! -d $(dir $@) ]; then mkdir -p $(dir $@); fi
	@echo > $@.tmp
	@for i in $(patsubst %, lisp/%, $(dependencies));\
	 do \
		echo "$(stem).ao: $$i.ao" >> $@.tmp;       \
		echo "$(stem).dep: $$i.dep" >> $@.tmp;     \
	 done;  \
	 mv $@.tmp $@

$(reqfiles): common/%.req: $(srcdir)/%.as
	@if [ ! -d $(dir $@) ]; then mkdir -p $(dir $@); fi
	@echo REQ $@
	@echo > $@
	@for i in $$(cat $(srcdir)/$*.as | sed -n -e '/^--DEPS:/s/^--DEPS://p'); \
	 do echo "$$i" >> $@; done
V   := 0
V_0 := @
V_1 := 

C_  :=
C_I := -WD+tfImport -WD+tipBup -Mpreview -WD+stabImport -WD+tf -WD+tiTf
C_F := -WD+lib -WD+tf -WD+tfFloat
C_L := -WD+lib -WD+symeFill -WD+sefoClose
C_T := -Mpreview -WD+tipBup -WD+tipTdn -WD+tiTf
C_T2 := -Mpreview -WD+tipBup -WD+tipTdn -WD+tf -WD+symeHas
C_T3 := -Mpreview -WD+tipBup -WD+tfs -WD+tfsMulti
C_X := $(X)
O_ := -O
O_0 :=
O_1 := -O

define aldor
$(ALDOR) -fap=$(arch)/$*.ap -I$(srcdir) -Y$(arch)/$(dir $*) \
	 -lAxiomLib=axiom_$(notdir $*) $(C_$(C)) $(O_$(O)) $(opts_$*) -fasy=$(dir $@)$(notdir $*).asy \
	 -fao=$@ $(srcdir)/$*.as
endef

I_ :=
I_D := -WD+fint

define aldor_interp
# cd is required because the interpreter can't find the current .ao file
# without it.
[ ! -z $(arch) ]
(cd $(arch)/$(dir $*); $(ALDOR) -I$(abs_srcdir) -Y.	\
	 -lAxiomLib=axiom_$(notdir $*)			\
	 $(C_$(C)) $(I_$(I)) $(O_$(O))			\
	 $(opts_$*) -ginterp $(notdir $*).as)
endef

define aldor_interp_cmd
(cd $(arch)/$(dir $*); gdb --args $(ALDOR) -I$(abs_srcdir) -Y. \
	 -lAxiomLib=axiom_$(notdir $*) $(C_$(C)) $(I_$(I)) $(O_$(O)) $(opts_$*) -ginterp $(arch)/$*.ao)
endef

define create_library
	[ ! -z $(arch) ]; \
	rm -f $(arch)/$(dir $*)libaxiom_$(notdir $*).al; \
	for i in $$(cat $(arch)/$*.dep); \
	do \
		if [ ! -f $(arch)/$$i.ao ]; then echo "missing $$i"; exit 1; fi;\
		ar r $(arch)/$(dir $*)libaxiom_$(notdir $*).al $(arch)/$$i.ao; \
	done;
endef

$(patsubst %,%.ao,$(native_library)): arch=native
$(patsubst %,%.ao,$(native_library)): all-build-tests
$(patsubst %,%.ao,$(native_library)): native/%.ao: $(srcdir)/%.as native/%.dep
	$(V_$(V))$(call build-ignoring, %.dep, $?, echo AO $@; $(create_library) $(aldor))
	@[ -f $@ ]

$(patsubst %,%.ao,$(lisp_library)): arch=lisp
$(patsubst %,%.ao,$(lisp_library)): all-build-tests
$(patsubst %,%.ao,$(lisp_library)): lisp/%.ao: $(srcdir)/%.as lisp/%.dep
	$(V_$(V))$(call build-ignoring, %.dep, $?, \
		echo AO $@;		\
		$(create_library)	\
		$(aldor))


$(patsubst %, %.cmd, $(native_library)): arch=native
$(patsubst %, %.cmd, $(native_library)): native/%.cmd:
	gdb --args $(aldor)

define build-ignoring
	$(if $(filter-out $(1), $(2)), $(3), )
endef

$(patsubst %, %.fm, $(native_library) $(lisp_library)): %.fm: %.ao
	$(ALDOR) -ffm=$@ $*.ao

$(patsubst %, %.c, $(native_library)): %.c: %.ao
	$(ALDOR) -fc=$@ $*.ao

$(patsubst %, %.o, $(native_library)): %.o: %.ao
	$(ALDOR) -Z db -fc=$*.c -fo=$@ $*.ao

$(patsubst %, %.exe, $(native_tests)): %.exe: %.ao %.dep
	rm -f $@
	make $(patsubst %, native/%.o, $(shell cat $*.dep))
	$(ALDOR) -Zdb -fc=$(patsubst %.exe,%.c, $@) -fx=$@ $*.ao $(patsubst %, native/%.o, $(shell cat $*.dep))

$(patsubst %, %.lsp, $(lisp_library)): %.lsp: %.ao
	@echo LSP $*
	@$(ALDOR) -flsp=$@ $*.ao

$(patsubst %, %.dep,$(lisp_library)): build-dep
$(patsubst %, %.dep, $(lisp_library)): lisp/%.dep: common/%.req

$(patsubst %, %.dep,$(native_library)): build-dep
$(patsubst %, %.dep, $(native_library)): native/%.dep: common/%.req

$(patsubst %, %.dep, $(lisp_library) $(native_library)): %.dep:
	@[ -d $(dir $@) ] || mkdir -p $(dir $@)
	@echo DEP $@
	@./build-dep $(firstword $(subst /,$(space),$@)) $@.tmp $(filter %.req, $^)
	@mv $@.tmp $@


$(patsubst %, show-%, $(library)): show
$(patsubst %, show-%, $(library)): show-%: %.ao
	aldor="$(ALDOR)" srcdir=$(srcdir) ./show $*

gloop-tests: $(patsubst %,gloop-%, $(tests))

$(patsubst %, native/%Run.as, $(tests)): $(srcdir)/Makefile.in
$(patsubst %, native/%Run.as, $(tests)): %Run.as: $(srcdir)/tests/TestSkel.as
	cat $(srcdir)/tests/TestSkel.as | sed -e 's/TEST/$(notdir $*)/g' > $@.tmp
	mv $@.tmp $@

$(patsubst %, native/%Run.dep, $(tests)): native/%Run.dep: native/%.dep
	@echo DEP_TEST $*
	cat native/$*.dep > $@.tmp
	echo $* >> $@.tmp
	mv $@.tmp $@

$(patsubst %, native/%Run.ao, $(tests)): arch=native
$(patsubst %, native/%Run.ao, $(tests)): native/%Run.ao: native/%.ao
$(patsubst %, native/%Run.ao, $(tests)): native/%.ao: native/%.as native/%.dep
	@echo AO_TEST $*
	@$(create_library)
	@$(aldor_interp)

#
# Gloop-TestX will run a test
#

$(patsubst %, gloop-%, $(library)): arch=native
$(patsubst %, gloop-%, $(tests)): gloop-%: gloop-%Run

$(patsubst %, gloop-%Run, $(tests)): stem=$*
$(patsubst %, gloop-%Run, $(tests)): gloop-%: native/%.ao
	@echo INTERP_TEST $(stem)
	$(create_library)
	$(aldor_interp)

#
# Check-TestX will run a test if it, or any dependencies, have changed
#

$(patsubst %, check-%, $(tests)): check-%: native/%.checked

$(patsubst %, native/%.checked, $(tests)): %.checked: %.ao
$(patsubst %, native/%.checked, $(tests)): native/%.checked:
	make gloop-$*
	touch $@

#
# lisp interface.
#

lisp_subset := $(basics) $(datatypes) $(integers) $(integers2)
lisp/load.input.req: $(srcdir)/Makefile.in
	@echo FILE_REQ $@
	@for i in $(lisp_subset); do echo $$i; done > $@

lisp/load.input.dep: lisp/load.input.req $(patsubst %, lisp/%.dep,$(lisp_subset))
	@echo FILE_DEP $@
	@[ -d $(dir $@) ] || mkdir -p $(dir $@)
	@./build-dep lisp $@.tmp lisp/load.input.req
	@mv $@.tmp $@

lisp/runtime.lsp:
	@echo EXTRACT $@
	@ar x  /home/pab/Work/aldordist/opt/share/lib/libfoam.al runtime.ao
	@$(ALDOR) -flsp=$@ runtime.ao
	@rm runtime.ao

lisp/load.input: lisp/load.input.dep
	@echo FILE $@
	@echo > $@
	@for i in $(filter-out lang, $(shell cat lisp/load.input.dep)); do if [ ! "$$i" = "" ]; then echo ")lib $$i" >> $@; fi; done

lisp/stuff.lisp: $(srcdir)/runtime/lisp/stuff.lisp
	cp $^ $@

#
# Cleaning
#

outputs_library = $(native_library) $(lisp_library)

mostlyclean-local:
	rm -rf $(foreach i, $(outputs_library), $(i).ao $(i).al $(i).mk $(i).dep)
	rm -rf common native lisp *.al *.ao *.mk *.o *.ap *.dep *.asy *.lsp *.req *.fm *.c

clean-local: mostlyclean-local

#
# Prebuild tests
#

allscripts := $(scripts) $(testscripts)

$(allscripts): %: $(srcdir)/%.sh
	cp $(srcdir)/$*.sh $@
	chmod a+x $@

run-all-tests: $(patsubst %,%.tested,$(testscripts))

all-build-tests: test-build-dep.tested

test-build-dep.tested: test-build-dep build-dep
	./test-build-dep
	touch $@

#
# Stupid make tricks
#

empty:=
space:= $(empty) $(empty)
